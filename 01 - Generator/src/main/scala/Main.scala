import MyJsonProtocol._
import org.apache.kafka.clients.producer.KafkaProducer
import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.serialization.StringSerializer
import spray.json._

import java.util.Properties
import java.util.UUID
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

object PeaceStateGenerator {
  val config = new Properties()
  config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092")
  config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])
  config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, classOf[StringSerializer])

  val producer = new KafkaProducer[Null, String](config)

  // We use a Future to execute this code without blocking the main thread
  // That way, even if Kafka takes a long time answering, reports will still be generated exactly every 1 second
  def produceReport(droneId: UUID, producer: KafkaProducer[Null, String]) = Future[Report] {
    try {
      // At each tick (every second), create a new Report
      val report = RandomReport.create(droneId)

      // Then, send it on the Kafka topic "reports"
      val record = new ProducerRecord[Null, String]("reports", report.toJson.compactPrint)
      producer.send(record).get()

      // Debug output
      printf(s"Sent report %s\n", report.toJson.compactPrint)

      report
    } catch {
      case e: Exception => e.printStackTrace()
      null
    }
  }

  // An infinite loop to generate reports every second
  def startProducer(droneId: UUID, producer: KafkaProducer[Null, String]): Unit = {
    produceReport(droneId, producer)

    Thread.sleep(1000)
    startProducer(droneId, producer)
  }

  def main(args: Array[String]): Unit = {
    // Generate a random UUID for the drone represented by this program
    // It will be used for all Reports generated by this instance
    // Restarting the program will generate a new one
    val droneId = UUID.randomUUID()

    startProducer(droneId, producer)
  }
}
